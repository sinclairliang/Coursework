.ORIG X3000
AND R0,R0,0
LEA R0,WELCOME
PUTS ; WELCOME MESSAGE
START
AND R0,R0,0
AND R1,R1,0
AND R2,R2,0 
AND R3,R3,0 ;FLAG1
AND R4,R4,0 ;MOSTLY USED AS COUNTERS
AND R5,R5,0 ;FLAG2
AND R6,R6,0 ;STORE VALUE
JSR RESET_ARRAY
LEA R0,PROMPT
PUTS ;WAIT FOR USERS' INPUT
GETC
OUT
JSR FETCH0;LD R1,AX ;CHECK WHETHER IT IS X
AND R2,R2,0
ADD R2,R1,R0 ;if it is X
BRZ EXIT ;START EXITING PROCEDURES

JSR FETCH1;LD R1,AD ;CHECK WHETHER IT IS D
AND R2,R2,0
ADD R2,R1,R0 ;if it is D
BRZ PREPARE ;START DECRYPT PROCEDURES

JSR FETCH2;LD R1,AE ;CHECK WHETHER IT IS E
AND R2,R2,0
ADD R2,R1,R0 ;if it is E
ADD R5,R5,#-1; R5 FLAG INDICATE ENCRYPTION
BRZ PREPARE ;START DECRYPT/ENCRYPT PROCEDURES

PREPARE
JSR FETCH8;LEA R0,QUES0
PUTS ;ASK FOR CIPHER
BREAKPOINT
GETC
OUT
ADD R1,R0,#0 ;STORE CIPHER IN R1
JSR FETCH3;LD R3,ZERO
ADD R1,R1,R3
LD R3,BACKSPACE ;CHECK WHETHER IT IS BACKSPACE
AND R2,R2,0
ADD R2,R3,R0 ;if it is BACKSPACE
BRZ CENTRALPROCESS ;START ASK FOR INPUT
JSR MULTI ;JMPR TO SUBROUTINE TO MUTIPLY NUMBERS BY 10
ADD R6,R1,R6 ;STORE THE CIPHER VALUE IN R6
BR BREAKPOINT ;ASK FOR ANOTHER NUMBER

CENTRALPROCESS
JSR FETCH9 ;LEA R0,QUES1
ST R6,CIPHER;STORE THE CIPHER VALUE IN CIPHER
PUTS ;ASK FOR INPUT
JSR FETCH4 ;LEA R1,MYARRAY
ASK
GETC
OUT
LD R3,BACKSPACE
AND R2,R2,0
ADD R2,R3,R0 ;if it is BACKSPACE
BRZ QUITTING
AND R2,R2,0

JSR STORE
ADD R1,R1,#1;MOVE TO NEXT ADDRESS
BR ASK; GO BACK TO ASK FOR ANOTHER INPUT

QUITTING
ADD R2,R5,#1
BRZ WRAPUP0;ENCR
BRP WRAPUP1;DECR

WRAPUP0
JSR FETCH15;LD R0,ANSWER
PUTS
JSR FETCH16;LEA R0,Encrypted
PUTS ;print <ENCR> MESSAGE
JSR ENCRYPT
;JSR FETCH6 ;LEA R0,MYARRAY
;PUTS ;ASK FOR INPUT
BR START

WRAPUP1
JSR FETCH15;LD R0,ANSWER
PUTS
JSR FETCH5;LEA R0,Encrypted
PUTS ;print <DECR> MESSAGE
JSR DECRYPT
;JSR FETCH6 ;LEA R0,MYARRAY
;PUTS ;ASK FOR INPUT
BR START
EXIT
LEA R0,GOODBYE
PUTS
HALT
BACKSPACE .FILL #-10
WELCOME .STRINGZ "Hello, welcome to my Caesar Cipher program!"
PROMPT .STRINGZ "\nDo you want to (E)ncrypt or D(ecrypt) or e(X)it? \n>"
GOODBYE .STRINGZ "\nGoodbye!!"
CIPHER .FILL #0
;-----------------------------SUBROUTINES-------------------------------------------------
; ---------------------------------------------
; MULTI SUBROUTINE                            |
; ---------------------------------------------
R0_ORIGINALM .fill 0
R4_ORIGINALM .fill 0
R5_ORIGINALM .fill 0
R6_ORIGINALM .fill 0
TEMPSTOREM .FILL 0
MULTI:
ST R0, R0_ORIGINALM
ST R4, R4_ORIGINALM
ST R5, R5_ORIGINALM

ST R7, TEMPSTOREM

AND R5,R5,0
ADD R5,R6,#0 ;COPY THE VALUE STORE IN R6, THE DECIMAL VALUE
AND R4,R4,0
ADD R4,R4,-9 ;COUNTER

COUNT 
BRZ RETURN ;IF R4 == 0, RETURN
ADD R6,R6,R5 ;ADD TO ITSELF FOR 10 TIMES IN THIS LOOP
ADD R4,R4,#1 ;INCREMENT THE COUNTER
BR COUNT
RETURN 
LD R0, R0_ORIGINALM
LD R4, R4_ORIGINALM
LD R5, R5_ORIGINALM

LD R7, TEMPSTOREM
RET
; -------- END OF MULTI SUBROUTINE -----------------
; --------------------------------------------------
; STORE SUBROUTINE                                 |
; Inputs:                                          |
; R1 = the index of a column of CIPHER_ARRAY (0-49)|
; R2 = the index of a row of CIPHER_ARRAY (0 or 1) |
; R0 = an ASCII character to store.                |
; Outputs:                                         |
; NONE                                             |
; --------------------------------------------------
R0_ORIGINAL .fill 0
R1_ORIGINAL .fill 0
R2_ORIGINAL .fill 0
R3_ORIGINAL .fill 0
TEMPSTORE .FILL 0
STORE:
;Backup the registers we use:
ST R0, R0_ORIGINAL
ST R1, R1_ORIGINAL
ST R2, R2_ORIGINAL
ST R3, R3_ORIGINAL
ST R7, TEMPSTORE
AND R3,R3,#0
ADD R3,R3,#1
AND R3,R3,R2;TO SEE IF R2 IS 0 OR 1
BRZ ZERO_OPR;IF ZERO GO TO ZERO OPRATION
AND R3,R3,#0
JSR FETCH7
;LD R3,FIFTY
ADD R1,R1,R3
STR R0,R1,#0
BR EXIT2
ZERO_OPR
STR R0,R1,#0
EXIT2
LD R1, R1_ORIGINAL
LD R2, R2_ORIGINAL
LD R3, R3_ORIGINAL
LD R7, TEMPSTORE
RET
; -------- END OF STORE SUBROUTINE -------------------
; ----------------------------------------------------
; LOAD SUBROUTINE                                    |
; Inputs:                                            |
; R1 = the index of a column of CIPHER_ARRAY (0-49)  |
; R2 = the index of a row of CIPHER_ARRAY (0 or 1)   |
; R0 = an ASCII character to store.                  |
; Outputs:                                           |
; R0 = the contents of CIPHER_ARRAY[R1, R2]          |
; ----------------------------------------------------
R0_ORIGINAL1 .fill 0
R1_ORIGINAL1 .fill 0
R2_ORIGINAL1 .fill 0
R3_ORIGINAL1 .fill 0
TEMPSTORE1 .FILL 0
LOAD:
ST R0, R0_ORIGINAL1
ST R1, R1_ORIGINAL1
ST R2, R2_ORIGINAL1
ST R3, R3_ORIGINAL1
ST R7, TEMPSTORE1
AND R3,R3,#0
ADD R3,R3,#1
AND R3,R3,R2;TO SEE IF R2 IS 0 OR 1
BRZ ZERO_OPR1;IF ZERO GO TO ZERO OPRATION
AND R3,R3,#0
JSR FETCH10
;LD R3,FIFTY
ADD R1,R1,R3
AND R2,R1,#0 
LDR R0,R1,#0
ZERO_OPR1
AND R2,R1,#0 
LDR R0,R1,#0
;LD R0, R0_ORIGINAL1
LD R1, R1_ORIGINAL1
LD R2, R2_ORIGINAL1
LD R3, R3_ORIGINAL1
LD R7, TEMPSTORE1
RET
; -------- END OF LOAD SUBROUTINE ------------------

; --------------------------------------------------
; ENCRYPT SUBROUTINE                               |
; Inputs:                                          |
; R0: A character to encrypt                       |
; Key: A number between 1 and 25 to shift R0 by    |
; Outputs:                                         |
; R0: The input character, EN-crypted by shifting  | 
;RIGHT                                             |
; --------------------------------------------------
R0_ORIGINAL2 .fill 0
R1_ORIGINAL2 .fill 0
R2_ORIGINAL2 .fill 0
R3_ORIGINAL2 .fill 0
R4_ORIGINAL2 .fill 0
R5_ORIGINAL2 .fill 0
R6_ORIGINAL2 .fill 0
TEMPSTORE2 .FILL 0
ENCRYPT:
;Backup the registers we use:
ST R0, R0_ORIGINAL2
ST R1, R1_ORIGINAL2
ST R2, R2_ORIGINAL2
ST R3, R3_ORIGINAL2
ST R4, R4_ORIGINAL2
ST R5, R5_ORIGINAL2; COUNTER TO 50
ST R6, R6_ORIGINAL2; INCREMENT
ST R7, TEMPSTORE2

JSR FETCH6;LEA R0,MYARRAY
JSR PRINT_ARRAY
JSR FETCH4 ;LEA R1,MYARRAY
ADD R1,R1,-1
JSR FETCH17;R5 = -50

SIGNAL
AND R2,R2,0
ADD R1,R1,1
AND R4,R4,0
ADD R4,R1,0;COPY THE ADDRESS AND STORE IN R4
ADD R5,R5,1
BRZ EXIT1
JSR LOAD ; R0 = [R1,R2]
ADD R1,R0,0;ADD R1,R0,#0;COPY WHATEVER IN R0 TO R1
JSR FETCH11;LD R3,LZ ;R3 = -122,z
ADD R2,R1,R3
BRP SKIP
JSR FETCH12;LD R3,CA ;R3 = -65,A
ADD R2,R1,R3
BRN SKIP
JSR FETCH13;LD R3,CZ ; R3 = -90,Z
ADD R2,R1,R3
BRZP IF1
BR PRE_CONVERT_UP

IF1;lower case
JSR FETCH14;LD R3,LA ;R3 = -122,a
ADD R2,R1,R3
BRN SKIP
BR PRE_CONVERT_LOWER

PRE_CONVERT_UP;COVERTING UPPER CASE
AND R0,R0,0
LD R3,CIPHER
ADD R0,R1,R3;ADD CIPHER KEY
JSR FETCH18;R6=(-90)
ADD R6,R6,R0;CHECK IF IT IS OVER 90(Z)
BRNZ STORING
ADD R0,R0,-12
ADD R0,R0,-12
ADD R0,R0,-2
BR STORING

PRE_CONVERT_LOWER;COVERTING UPPER CASE
AND R0,R0,0
LD R3,CIPHER
ADD R0,R1,R3;ADD CIPHER KEY
JSR FETCH21;R6=(-122)
ADD R6,R6,R0;CHECK IF IT IS OVER 122(z)
BRNZ STORING
ADD R0,R0,-12
ADD R0,R0,-12
ADD R0,R0,-2
BR STORING

STORING
AND R2,R2,0
ADD R2,R2,1
AND R1,R1,0
ADD R1,R4,0;COPY THE ADDRESS ONCE IN R4 AND STORE IN R1
JSR STORE
BR SIGNAL
SKIP
ADD R0,R1,0
AND R2,R2,0
ADD R2,R2,1
AND R1,R1,0
ADD R1,R4,0;COPY THE ADDRESS ONCE IN R4 AND STORE IN R1
JSR STORE
BR SIGNAL
EXIT1

JSR FETCH5
PUTS
JSR FETCH6;R0=MYARRAY
JSR FETCH10;R3=50
ADD R0,R0,R3
JSR PRINT_ARRAY
LD R0, R0_ORIGINAL2
LD R1, R1_ORIGINAL2
LD R2, R2_ORIGINAL2
LD R3, R3_ORIGINAL2
LD R4, R4_ORIGINAL2
LD R5, R5_ORIGINAL2
LD R6, R6_ORIGINAL2
LD R7, TEMPSTORE2
RET
; -------- END OF ENCRYPT SUBROUTINE --------------

; --------------------------------------------------
; DECRYPT SUBROUTINE                               |
; Inputs:                                          |
; R0: A character to encrypt                       |
; Key: A number between 1 and 25 to shift R0 by    |
; Outputs:                                         |
; R0: The input character, DE-crypted by shifting  | 
;RIGHT                                             |
; --------------------------------------------------
R0_ORIGINAL3 .fill 0
R1_ORIGINAL3 .fill 0
R2_ORIGINAL3 .fill 0
R3_ORIGINAL3 .fill 0
R4_ORIGINAL3 .fill 0
R5_ORIGINAL3 .fill 0
R6_ORIGINAL3 .fill 0
TEMPSTORE3 .FILL 0
DECRYPT:
;Backup the registers we use:
ST R0, R0_ORIGINAL3
ST R1, R1_ORIGINAL3
ST R2, R2_ORIGINAL3
ST R3, R3_ORIGINAL3
ST R4, R4_ORIGINAL3
ST R5, R5_ORIGINAL3; COUNTER TO 50
ST R6, R6_ORIGINAL3; INCREMENT
ST R7, TEMPSTORE3

JSR FETCH6;LEA R0,MYARRAY
JSR PRINT_ARRAY
JSR FETCH4 ;LEA R1,MYARRAY
ADD R1,R1,-1
JSR FETCH17;R5 = -50

SIGNAL2
AND R2,R2,0
ADD R1,R1,1
AND R4,R4,0
ADD R4,R1,0;COPY THE ADDRESS AND STORE IN R4
ADD R5,R5,1
BRZ EXIT3
JSR LOAD ; R0 = [R1,R2]
ADD R1,R0,0;ADD R1,R0,#0;COPY WHATEVER IN R0 TO R1
JSR FETCH11;LD R3,LZ ;R3 = -122,z
ADD R2,R1,R3
BRP SKIP2
JSR FETCH12;LD R3,CA ;R3 = -65,A
ADD R2,R1,R3
BRN SKIP2
JSR FETCH13;LD R3,CZ ; R3 = -65,z
ADD R2,R1,R3
BRZP IF2
BR PRE_CONVERT2_UP

IF2;lower case
JSR FETCH14;LD R3,LA ;R3 = -122,a
ADD R2,R1,R3
BRN SKIP
BR PRE_CONVERT2_LOWER

PRE_CONVERT2_UP;COVERTING UPPER CASE
AND R0,R0,0
LD R3,CIPHER
NOT R3,R3
ADD R3,R3,1;2'S COMP
ADD R0,R1,R3;MINUS CIPHER KEY
JSR FETCH20;R6=(-65)
ADD R6,R6,R0;CHECK IF IT IS OVER 65(A)
BRZP STORING2
ADD R0,R0,+12
ADD R0,R0,+12
ADD R0,R0,+2
BR STORING2

PRE_CONVERT2_LOWER;COVERTING UPPER CASE
AND R0,R0,0
LD R3,CIPHER
NOT R3,R3
ADD R3,R3,1;2'S COMP
ADD R0,R1,R3;MINUS CIPHER KEY
JSR FETCH19;R6=(-65)
ADD R6,R6,R0;CHECK IF IT IS BELOW a (122)
BRZP STORING2
ADD R0,R0,+12
ADD R0,R0,+12
ADD R0,R0,+2
BR STORING2

STORING2
AND R2,R2,0
ADD R2,R2,1
AND R1,R1,0
ADD R1,R4,0;COPY THE ADDRESS ONCE IN R4 AND STORE IN R1
JSR STORE
BR SIGNAL2
SKIP2
ADD R0,R1,0
AND R2,R2,0
ADD R2,R2,1
AND R1,R1,0
ADD R1,R4,0;COPY THE ADDRESS ONCE IN R4 AND STORE IN R1
JSR STORE
BR SIGNAL2

EXIT3
JSR FETCH16
PUTS
JSR FETCH6;R0=MYARRAY
JSR FETCH10;R3=50
ADD R0,R0,R3
JSR PRINT_ARRAY
LD R0, R0_ORIGINAL3
LD R1, R1_ORIGINAL3
LD R2, R2_ORIGINAL3
LD R3, R3_ORIGINAL3
LD R4, R4_ORIGINAL3
LD R5, R5_ORIGINAL3
LD R6, R6_ORIGINAL3
LD R7, TEMPSTORE3
RET

; -------- END OF DECRYPT SUBROUTINE --------------
; ---------------------------------------------
; PRINT_ARRAY SUBROUTINE                      |
; Inputs:                                     |
; None                                        |
; Outputs:                                    |
; None                                        |
; ---------------------------------------------
R0_ORIGINALP .fill 0
TEMPSTOREP .FILL 0
PRINT_ARRAY:
ST R0, R0_ORIGINALP
ST R7, TEMPSTOREP
;LEA R0,MYARRAY
PUTS
LD R0, R0_ORIGINALP
LD R7, TEMPSTOREP
RET
; ------- END OF PRINT_ARRAY SUBROUTINE -------

; ---------------------------------------------
; RESET_ARRAY SUBROUTINE                      |
; Inputs:                                     |
; None                                        |
; Outputs:                                    |
; None                                        |
; ---------------------------------------------
R0_ORIGINALR .fill 0
R1_ORIGINALR .fill 0
R3_ORIGINALR .fill 0
TEMPSTORER .fill 0
RESET_ARRAY:
ST R0, R0_ORIGINALR
ST R1, R1_ORIGINALR
ST R3, R3_ORIGINALR
ST R7, TEMPSTORER

AND R0,R0,0
JSR FETCH7; R3=50
ADD R3,R3,R3;R3 = 100
LEA R1,MYARRAY
ADD R1,R1,-1
BEGIN
ADD R3,R3,#-1
BRZ EXIT4
ADD R1,R1,1
STR R0,R1,#0
BR BEGIN
EXIT4
LD R0, R0_ORIGINALR
LD R1, R1_ORIGINALR
LD R3, R3_ORIGINALR
LD R7, TEMPSTORER

RET
; ------- END OF RESET_ARRAY SUBROUTINE -------



FETCH0:
LD R1,AX ;CHECK WHETHER IT IS X
RET
FETCH1:
LD R1,AD ;CHECK WHETHER IT IS D
RET
FETCH2:
LD R1,AE ;CHECK WHETHER IT IS E
RET
FETCH3:
LD R3,ZERO
RET
FETCH4:
LEA R1,MYARRAY
RET
FETCH5:
LEA R0,Encrypted
RET
FETCH6:
LEA R0,MYARRAY
RET
FETCH7:
LD R3,FIFTY
RET
FETCH8:
LEA R0,QUES0
RET
FETCH9:
LEA R0,QUES1
RET
FETCH10:
LD R3,FIFTY
RET
FETCH11:
LD R3,LZ ;R3 = -122,z
RET
FETCH12:
LD R3,CA ;R3 = -65,A
RET
FETCH13:
LD R3,CZ ; R3 = -65,z
RET
FETCH14:
LD R3,LA ;R3 = -122,a
RET
FETCH15:
LEA R0,ANSWER
RET
FETCH16:
LEA R0,Decrypted
RET
FETCH17:
LD R5,NFIFTY
RET
FETCH18:
LD R6,CZ
RET
FETCH19:
LD R6,LA
RET
FETCH20:
LD R6,CA
RET
FETCH21:
LD R6,LZ
RET
ANSWER .STRINGZ "\nHere is your string and the decrypted result"
QUES0 .STRINGZ "\nWhat is the cipher (1-25)?\n"
QUES1 .STRINGZ "What is the string (up to 200 characters)?\n"
Encrypted .STRINGZ "\n<Encrypted>: "
Decrypted .STRINGZ "\n<Decrypted>: "
AD .FILL #-68
AE .FILL #-69
AX .FILL #-88
CA .FILL #-65
CZ .FILL #-90
LA .FILL #-97
LZ .FILL #-122
ZERO .FILL #-48
FIFTY .FILL #50
NFIFTY .FILL #-50
MYARRAY .BLKW 100
.END